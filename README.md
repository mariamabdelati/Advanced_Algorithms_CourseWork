## Advanced Algorithms CourseWork
<p align="center" name="top"> </p>

*Java Implemented Portfolio -- University Junior Year*
##### Mariam Abdelati

### Table of Contents

- [Task One](#taskone)
- [Task Two](#tasktwo)
- [Task Three](#taskthree)
- [Task Five](#taskfive)
- [Task Six](#tasksix)
- [Task Seven](#taskseven)
- [Task Eight](#taskeight)

---

### Task One <a id='taskone'></a>

Write a recursive method that given a binary tree, creates a new tree where
every node is duplicated. Every duplicated node has to be inserted as a left child
of the node. <br>
Hint: The left child that was inserted should not be duplicated again or else your
algorithm will run forever. <br>
For example, for the following tree:

<img src="https://i.postimg.cc/X7tFLL2Z/binary-tree.png" alt="Binary Tree Unduplicated" width="200">

<br>
<br>
should return the following tree
<br>
<br>

<img src="https://i.postimg.cc/W4x1LYkr/duplicated-binary-tree.png" alt="Duplicated Binary Tree" width="240">

---
### Task Two  <a id='tasktwo'></a>

Implement a red-black tree from scratch. Implementing all the basic
operations of a red-black tree. Test your program by displaying the RB tree, after
performing each of those operations: <br>
&emsp; a. create a tree
&emsp; b. insert the following to the tree [30, 15, 45, 35, 60, 55] and show the
resulting tree after each operation.
&emsp; c. delete 45 from the tree and show the resulting tree.

---
### Task Three  <a id='taskthree'></a>

Implement the heapsort algorithm from scratch. Your program should
receive a list (or array from the user) and output a sorted list. Test you program
against the following set of elements \[90,87,65,11,23,45,21] 

---
### Task Five  <a id='taskfive'></a>

Implement both the adjacency matrix and adjacency list representations of a
graph, use the graph below as a testing example for your main program:

<img src="https://i.postimg.cc/3wzwFnjL/graph.png" alt="Graph" width="688">

---
### Task Six  <a id='tasksix'></a>

Implement both the <u>**Breadth**</u> first search traversal and the  <u>**Depth**</u> first search
traversal of a graph, use the graph from the task above to test your main
program.

---
### Task Seven  <a id='taskseven'></a>

Implement a Primâ€™s algorithm variation, where we need to find the spanning
tree based on the largest distance not the smallest. Use the following graph as
an example for testing your program, show the output of the program as a list of
nodes representing the spanning tree. In addition, you should justify the usage
of any other ADT for storing and processing inputs or outputs.

<img src="https://i.postimg.cc/kMpTFSL2/prims-algorithm.png" alt="Prim's Algorithm" width="1662">

---
### Task Eight  <a id='taskeight'></a>

Search for sorting algorithms which could be implemented as a concurrent
algorithm. Justify your findings. Then implement Merge sort algorithm as a
concurrent application


---
<p align="center">
  <a href="#top">Back to Top</a>
</p>
